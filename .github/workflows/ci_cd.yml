name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # 📥 Récupérer le code
      - name: Checkout code
        uses: actions/checkout@v3

      # 🔑 Connexion à Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      # 🐳 Build & push backend
      - name: Build and push backend Docker image
        working-directory: backend
        run: |
          docker build -t hakim2002/backend:${{ github.sha }} .
          docker push hakim2002/backend:${{ github.sha }}

      # 🐳 Build & push frontend AVEC CORRECTION INDEX.HTML
      - name: Build and push frontend Docker image
        working-directory: frontend
        run: |
          # Corriger les erreurs dans index.html avant le build
          echo "🔧 Correction des erreurs dans index.html..."
          sed -i 's/faxicon\.ico/favicon.ico/g' src/index.html
          sed -i 's/bootstrap@9\.1\.3/bootstrap@5.1.3/g' src/index.html
          sed -i 's/="\/@export"/="viewport"/g' src/index.html
          
          # Vérifier les corrections
          echo "=== INDEX.HTML CORRIGÉ ==="
          grep -E "favicon.ico|bootstrap@5.1.3|viewport" src/index.html || echo "Aucune correction nécessaire"
          
          # Build Angular
          npm install
          npm run build --prod
          
          # Vérifier que le build a fonctionné
          if [ -f "dist/demoapp/index.html" ]; then
            echo "✅ Build Angular réussi"
            ls -la dist/demoapp/ | head -10
          else
            echo "❌ Build Angular échoué"
            ls -la dist/
            exit 1
          fi
          
          # Build et push Docker
          docker build -t hakim2002/frontend:${{ github.sha }} .
          docker push hakim2002/frontend:${{ github.sha }}

      # 🔹 Se connecter à Azure
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # ⚙️ Configurer kubectl pour AKS
      - name: Set up kubectl
        uses: azure/aks-set-context@v3
        with:
          resource-group: myAKSCluster_group
          cluster-name: myAKSCluster
      
      # 🔐 CRÉER LE SECRET MYSQL
      - name: Create MySQL Secret
        run: |
          kubectl create secret generic mysql-secret \
            --from-literal=username=root \
            --from-literal=password=password \
            --namespace=default --dry-run=client -o yaml | kubectl apply -f -

      # 🗄️ Déployer MySQL
      - name: Deploy MySQL
        run: |
          # Vérifier l'état actuel
          echo "📊 État actuel de MySQL:"
          kubectl get deployment,pod,service -n default -l app=mysql 2>/dev/null || echo "Aucun déploiement MySQL trouvé"
          
          # Supprimer l'ancien déploiement s'il est bloqué
          if kubectl get deployment mysql-deployment -n default &>/dev/null; then
            echo "🔄 Suppression de l'ancien déploiement MySQL..."
            kubectl delete deployment mysql-deployment -n default --timeout=30s
            sleep 10
          fi
          
          # Appliquer les fichiers MySQL
          echo "🔧 Déploiement de MySQL..."
          kubectl apply -f k8s-manifests/database/ -n default
          
          # Attendre le démarrage de MySQL
          echo "⏳ Attente du démarrage de MySQL..."
          sleep 40
          
          # Vérification
          kubectl get pods -n default -l app=mysql
          echo "✅ MySQL déployé"

      # 🚀 Déployer backend sur AKS
      - name: Deploy backend to AKS
        run: |
          sed -i "s|image: .*|image: hakim2002/backend:${{ github.sha }}|" k8s-manifests/backend/deployment-backend.yaml
          kubectl apply -f k8s-manifests/backend/ -n default
          
          # Attendre le backend avec timeout long
          echo "⏳ Attente du backend..."
          kubectl rollout status deployment/backend-deployment -n default --timeout=600s

      # 🚀 Déployer frontend sur AKS
      - name: Deploy frontend to AKS
        run: |
          sed -i "s|image: .*|image: hakim2002/frontend:${{ github.sha }}|" k8s-manifests/frontend/deployment-frontend.yaml
          kubectl apply -f k8s-manifests/frontend/ -n default
          
          # Attendre le frontend
          echo "⏳ Attente du frontend..."
          kubectl rollout status deployment/frontend-deployment -n default --timeout=300s

      # 🌐 OBTENIR L'URL DE L'APPLICATION
      - name: Get Application URL
        run: |
          echo "🎯 VOTRE APPLICATION EST MAINTENANT EN LIGNE !"
          echo "=============================================="
          
          # Attendre que l'IP LoadBalancer soit assignée
          echo "⏳ Attente de l'IP LoadBalancer..."
          sleep 30
          
          # Obtenir l'IP du frontend
          IP=$(kubectl get service frontend-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          if [ -n "$IP" ]; then
            echo "🌐 URL de l'application : http://$IP"
            echo "::notice::🌐 Votre application est disponible à l'adresse : http://$IP"
          else
            echo "⚠️ L'IP LoadBalancer est en cours d'attribution..."
            echo "💡 Elle peut prendre 2-5 minutes à apparaître"
            kubectl get service frontend-service -n default
          fi
          
          echo ""
          echo "📊 État final des services :"
          kubectl get services -n default
          
          echo ""
          echo "🐳 État final des pods :"
          kubectl get pods -n default

      # 📊 Vérification finale
      - name: Verify deployment
        run: |
          echo "=== VÉRIFICATION FINALE ==="
          echo "✅ Déploiement terminé avec succès !"
          
          # Vérifier que les applications répondent
          echo "🔍 Vérification de l'état des applications..."
          
          # Backend health check
          if kubectl get pod -l app=backend -n default &>/dev/null; then
            echo "🔧 Backend : $(kubectl get pod -l app=backend -n default -o jsonpath='{.items[0].status.phase}')"
          fi
          
          # Frontend health check  
          if kubectl get pod -l app=frontend -n default &>/dev/null; then
            echo "🎨 Frontend : $(kubectl get pod -l app=frontend -n default -o jsonpath='{.items[0].status.phase}')"
          fi
          
          # MySQL health check
          if kubectl get pod -l app=mysql -n default &>/dev/null; then
            echo "🗄️ MySQL : $(kubectl get pod -l app=mysql -n default -o jsonpath='{.items[0].status.phase}')"
          fi