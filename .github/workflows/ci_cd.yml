name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # ğŸ“¥ RÃ©cupÃ©rer le code
      - name: Checkout code
        uses: actions/checkout@v3

      # ğŸ”‘ Connexion Ã  Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      # ğŸ³ Build & push backend
      - name: Build and push backend Docker image
        working-directory: backend
        run: |
          docker build -t hakim2002/backend:${{ github.sha }} .
          docker push hakim2002/backend:${{ github.sha }}

      # ğŸ³ Build & push frontend AVEC CORRECTION INDEX.HTML
      - name: Build and push frontend Docker image
        working-directory: frontend
        run: |
          # Corriger les erreurs dans index.html avant le build
          echo "ğŸ”§ Correction des erreurs dans index.html..."
          sed -i 's/faxicon\.ico/favicon.ico/g' src/index.html
          sed -i 's/bootstrap@9\.1\.3/bootstrap@5.1.3/g' src/index.html
          sed -i 's/="\/@export"/="viewport"/g' src/index.html
          
          # VÃ©rifier les corrections
          echo "=== INDEX.HTML CORRIGÃ‰ ==="
          grep -E "favicon.ico|bootstrap@5.1.3|viewport" src/index.html || echo "Aucune correction nÃ©cessaire"
          
          # Build Angular
          npm install
          npm run build --prod
          
          # VÃ©rifier que le build a fonctionnÃ©
          if [ -f "dist/demoapp/index.html" ]; then
            echo "âœ… Build Angular rÃ©ussi"
            ls -la dist/demoapp/ | head -10
          else
            echo "âŒ Build Angular Ã©chouÃ©"
            ls -la dist/
            exit 1
          fi
          
          # Build et push Docker
          docker build -t hakim2002/frontend:${{ github.sha }} .
          docker push hakim2002/frontend:${{ github.sha }}

      # ğŸ”¹ Se connecter Ã  Azure
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # âš™ï¸ Configurer kubectl pour AKS
      - name: Set up kubectl
        uses: azure/aks-set-context@v3
        with:
          resource-group: myAKSCluster_group
          cluster-name: myAKSCluster
      
      # ğŸ” CRÃ‰ER LE SECRET MYSQL
      - name: Create MySQL Secret
        run: |
          kubectl create secret generic mysql-secret \
            --from-literal=username=root \
            --from-literal=password=password \
            --namespace=default --dry-run=client -o yaml | kubectl apply -f -

      # ğŸ—„ï¸ DÃ©ployer MySQL
      - name: Deploy MySQL
        run: |
          # VÃ©rifier l'Ã©tat actuel
          echo "ğŸ“Š Ã‰tat actuel de MySQL:"
          kubectl get deployment,pod,service -n default -l app=mysql 2>/dev/null || echo "Aucun dÃ©ploiement MySQL trouvÃ©"
          
          # Supprimer l'ancien dÃ©ploiement s'il est bloquÃ©
          if kubectl get deployment mysql-deployment -n default &>/dev/null; then
            echo "ğŸ”„ Suppression de l'ancien dÃ©ploiement MySQL..."
            kubectl delete deployment mysql-deployment -n default --timeout=30s
            sleep 10
          fi
          
          # Appliquer les fichiers MySQL
          echo "ğŸ”§ DÃ©ploiement de MySQL..."
          kubectl apply -f k8s-manifests/database/ -n default
          
          # Attendre le dÃ©marrage de MySQL
          echo "â³ Attente du dÃ©marrage de MySQL..."
          sleep 40
          
          # VÃ©rification
          kubectl get pods -n default -l app=mysql
          echo "âœ… MySQL dÃ©ployÃ©"

      # ğŸš€ DÃ©ployer backend sur AKS
      - name: Deploy backend to AKS
        run: |
          sed -i "s|image: .*|image: hakim2002/backend:${{ github.sha }}|" k8s-manifests/backend/deployment-backend.yaml
          kubectl apply -f k8s-manifests/backend/ -n default
          
          # Attendre le backend avec timeout long
          echo "â³ Attente du backend..."
          kubectl rollout status deployment/backend-deployment -n default --timeout=600s

      # ğŸš€ DÃ©ployer frontend sur AKS
      - name: Deploy frontend to AKS
        run: |
          sed -i "s|image: .*|image: hakim2002/frontend:${{ github.sha }}|" k8s-manifests/frontend/deployment-frontend.yaml
          kubectl apply -f k8s-manifests/frontend/ -n default
          
          # Attendre le frontend
          echo "â³ Attente du frontend..."
          kubectl rollout status deployment/frontend-deployment -n default --timeout=300s

      # ğŸŒ OBTENIR L'URL DE L'APPLICATION
      - name: Get Application URL
        run: |
          echo "ğŸ¯ VOTRE APPLICATION EST MAINTENANT EN LIGNE !"
          echo "=============================================="
          
          # Attendre que l'IP LoadBalancer soit assignÃ©e
          echo "â³ Attente de l'IP LoadBalancer..."
          sleep 30
          
          # Obtenir l'IP du frontend
          IP=$(kubectl get service frontend-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          if [ -n "$IP" ]; then
            echo "ğŸŒ URL de l'application : http://$IP"
            echo "::notice::ğŸŒ Votre application est disponible Ã  l'adresse : http://$IP"
          else
            echo "âš ï¸ L'IP LoadBalancer est en cours d'attribution..."
            echo "ğŸ’¡ Elle peut prendre 2-5 minutes Ã  apparaÃ®tre"
            kubectl get service frontend-service -n default
          fi
          
          echo ""
          echo "ğŸ“Š Ã‰tat final des services :"
          kubectl get services -n default
          
          echo ""
          echo "ğŸ³ Ã‰tat final des pods :"
          kubectl get pods -n default

      # ğŸ“Š VÃ©rification finale
      - name: Verify deployment
        run: |
          echo "=== VÃ‰RIFICATION FINALE ==="
          echo "âœ… DÃ©ploiement terminÃ© avec succÃ¨s !"
          
          # VÃ©rifier que les applications rÃ©pondent
          echo "ğŸ” VÃ©rification de l'Ã©tat des applications..."
          
          # Backend health check
          if kubectl get pod -l app=backend -n default &>/dev/null; then
            echo "ğŸ”§ Backend : $(kubectl get pod -l app=backend -n default -o jsonpath='{.items[0].status.phase}')"
          fi
          
          # Frontend health check  
          if kubectl get pod -l app=frontend -n default &>/dev/null; then
            echo "ğŸ¨ Frontend : $(kubectl get pod -l app=frontend -n default -o jsonpath='{.items[0].status.phase}')"
          fi
          
          # MySQL health check
          if kubectl get pod -l app=mysql -n default &>/dev/null; then
            echo "ğŸ—„ï¸ MySQL : $(kubectl get pod -l app=mysql -n default -o jsonpath='{.items[0].status.phase}')"
          fi